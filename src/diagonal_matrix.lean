/-
Copyright (c) 2021 Lu-Ming Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Lu-Ming Zhang.
-/
import symmetric_matrix
import main1

/-!
# Diagonal matrices

This file contains the definition and basic results about diagonal matrices.

## Main results

- `matrix.has_orthogonal_rows`: `A.has_orthogonal_rows` means `A` has orthogonal (with respect to `dot_product`) rows.
- `matrix.has_orthogonal_cols`: `A.has_orthogonal_cols` means `A` has orthogonal (with respect to `dot_product`) columns.
- `matrix.is_diagonal`: a proposition that stats a given square matrix `A` is diagonal (i.e. `∀ i j, i ≠ j → A i j = 0`).

## Tags

diag, diagonal, matrix
-/

namespace matrix

variables {α R I J : Type*} [fintype I] [fintype J]
open_locale matrix

/-- `A.has_orthogonal_rows` means matrix `A` has orthogonal (with respect to `dot_product`) rows. -/
def has_orthogonal_rows [has_mul α] [add_comm_monoid α] (A : matrix I J α) : Prop := 
∀ ⦃i₁ i₂⦄, i₁ ≠ i₂ → dot_product (A i₁) (A i₂) = 0

/-- `A.has_orthogonal_cols` means matrix `A` has orthogonal (with respect to `dot_product`) columns. -/
def has_orthogonal_cols [has_mul α] [add_comm_monoid α] (A : matrix I J α) : Prop := 
∀ ⦃i₁ i₂⦄, i₁ ≠ i₂ → dot_product (λ j, A  j i₁) (λ j, A j i₂) = 0

/-- `Aᵀ` has orthogonal rows iff `A` has orthogonal columns. -/
lemma transpose_has_orthogonal_rows_iff_has_orthogonal_cols
[has_mul α] [add_comm_monoid α] (A : matrix I J α) :
Aᵀ.has_orthogonal_rows ↔ A.has_orthogonal_cols :=
by simp [has_orthogonal_rows, has_orthogonal_cols, trans_row_eq_col]

/-- `Aᵀ` has orthogonal columns iff `A` has orthogonal rows. -/
lemma transpose_has_orthogonal_cols_iff_has_orthogonal_rows
[has_mul α] [add_comm_monoid α] (A : matrix I J α) :
Aᵀ.has_orthogonal_cols ↔ A.has_orthogonal_rows :=
by simp [has_orthogonal_rows, has_orthogonal_cols, trans_row_eq_col]

/-- `A.is_diagonal` means square matrix `A` is a dianogal matrix: `∀ i j, i ≠ j → A i j = 0`. -/
def is_diagonal [has_zero α] (A : matrix I I α) : Prop := ∀ i j, i ≠ j → A i j = 0

/-- Non-diagonal entries equal zero. -/
@[simp] lemma is_diagonal.apply_ne [has_zero α] {A : matrix I I α} 
(ha : A.is_diagonal) {i j : I} (h : ¬ i = j) : 
A i j = 0 := ha i j h

/-- Non-diagonal entries equal zero. -/
@[simp] lemma is_diagonal.apply_ne' [has_zero α] {A : matrix I I α} 
(ha : A.is_diagonal) {i j : I} (h : ¬ j = i) : 
A i j = 0 := ha.apply_ne (ne.symm h)

/-- Matrix `A` is diagonal iff there is a vector `d` such that A is the diagonal matix generated by `d`. -/
lemma is_diagonal_iff_eq_diagonal [has_zero α] [decidable_eq I] (A : matrix I I α) : 
A.is_diagonal ↔ (∃ d, A = diagonal d):=
begin
  split,
  { intros h, use (λ i, A i i), 
    ext, 
    specialize h i j,
    by_cases i = j; 
    simp * at *, },
  { rintros ⟨d, rfl⟩ i j h, simp *}
end

/-- Every unit matrix is diagonal. -/
@[simp] lemma is_diagonal_of_unit [has_zero α] (A : matrix unit unit α) : A.is_diagonal :=
by {intros i j h, have h':= @unit.ext i j, simp* at *}

/-- Every zero matrix is diagonal. -/
@[simp] lemma is_diagonal_of_zero [has_zero α] : (0 : matrix I I α).is_diagonal :=
λ i j h, by simp

/-- Every identity matrix is diagonal. -/
@[simp] lemma is_diagonal_of_one [decidable_eq I] [has_zero α] [has_one α] : (1 : matrix I I α).is_diagonal :=
by {intros i j h, simp *}

/-- `smul` identity matrix `1` is diagonal. -/
@[simp] lemma is_diagonal_of_smul_one
[decidable_eq I] [monoid R] [add_monoid α] [has_one α] [distrib_mul_action R α] (k : R) : 
(k • (1 : matrix I I α)).is_diagonal := by {intros i j h, simp *}

/-- Matrix `k • A` is diagonal if `A` is. -/
@[simp] lemma smul_is_diagonal_of [monoid R] [add_monoid α] [distrib_mul_action R α] 
{k : R} {A : matrix I I α} (ha : A.is_diagonal): 
(k • A).is_diagonal := by {intros i j h, simp [ha i j h]}

/-- The sum of two diagonal matrices is diagonal. -/
@[simp] lemma is_diagonal_add [add_zero_class α] {A B : matrix I I α} (ha : A.is_diagonal) (hb : B.is_diagonal) :
(A + B).is_diagonal := by {intros i j h, simp *, rw [ha i j h, hb i j h], simp}

/-- The block matrix `A.from_blocks B C D` is diagonal if  `A` and `D` are diagonal and `B` and `C` are `0`. -/
lemma is_diagnoal_of_block_conditions [has_zero α] 
{A : matrix I I α} {B : matrix I J α} {C : matrix J I α} {D : matrix J J α} :
(A.is_diagonal) ∧ (D.is_diagonal) ∧ (B = 0) ∧ (C = 0) → (A.from_blocks B C D).is_diagonal:=
begin
  rintros h (i | i) (j | j) hij,
  any_goals {rcases h with ⟨ha, hd, hb, hc⟩, simp* at *},
  {have h' : i ≠ j, {simp* at *}, exact ha i j h'},
  {have h' : i ≠ j, {simp* at *}, exact hd i j h'},
end

/-- A symmetric block matrix `A.from_blocks B C D` is diagonal if  `A` and `D` are diagonal and `B` is `0`. -/
lemma is_diagnoal_of_sym_block_conditions [has_zero α] 
{A : matrix I I α} {B : matrix I J α} {C : matrix J I α} {D : matrix J J α}
(sym : (A.from_blocks B C D).is_sym) :
(A.is_diagonal) ∧ (D.is_diagonal) ∧ (B = 0) → (A.from_blocks B C D).is_diagonal:=
begin
  rintros h,
  apply is_diagnoal_of_block_conditions,
  refine ⟨h.1, h.2.1, h.2.2, _⟩,
  obtain ⟨g1, g2, g3, g4⟩ := block_conditions_of_is_sym sym,
  simp [← g4, h.2.2]
end

/-- A different form of `matrix.is_diagnoal_of_sym_block_conditions`. -/
lemma is_diagnoal_of_sym_block_conditions' [has_zero α] 
{A : matrix I I α} {B : matrix I J α} {C : matrix J I α} {D : matrix J J α}
{M : matrix (I ⊕ J) (I ⊕ J) α} (sym : M.is_sym) (h : M = A.from_blocks B C D) :
(A.is_diagonal) ∧ (D.is_diagonal) ∧ (B = 0) → M.is_diagonal:=
by rw h at *; convert is_diagnoal_of_sym_block_conditions sym

/-- `(A ⬝ Aᵀ).is_diagonal` iff `A.has_orthogonal_rows`. -/
lemma mul_tranpose_is_diagonal_iff_has_orthogonal_rows
[has_mul α] [add_comm_monoid α] {A : matrix I J α} :
(A ⬝ Aᵀ).is_diagonal ↔ A.has_orthogonal_rows :=
begin
  split,
  { rintros h i1 i2 hi,
    have h' := h i1 i2 hi,
    simp [dot_product, mul_apply,*] at *, },
  { intros ha i j h,
    have h':= ha h,
    simp [mul_apply, *, dot_product] at *,
  }
end

/-- `(Aᵀ ⬝ A).is_diagonal` iff `A.has_orthogonal_cols`. -/
lemma tranpose_mul_is_diagonal_iff_has_orthogonal_cols
[has_mul α] [add_comm_monoid α] {A : matrix I J α} :
(Aᵀ ⬝ A).is_diagonal ↔ A.has_orthogonal_cols :=
begin
  simp [←transpose_has_orthogonal_rows_iff_has_orthogonal_cols],
  convert mul_tranpose_is_diagonal_iff_has_orthogonal_rows,
  simp
end

/-- `(A ⊗ B).is_diagonal` if both `A` and `B` are diagonal. -/
lemma K_is_diagonal_of [mul_zero_class α]
{A : matrix I I α} {B : matrix J J α} (ga: A.is_diagonal) (gb: B.is_diagonal): 
(A ⊗ B).is_diagonal := 
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ h,
  simp [Kronecker],
  by_cases ha: a = c,
  have hb: b ≠ d, {intros hb, rw [ha, hb] at h, apply h rfl},
  rw (gb _ _ hb), simp,
  rw (ga _ _ ha), simp,
end

end matrix